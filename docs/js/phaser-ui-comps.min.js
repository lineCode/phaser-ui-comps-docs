(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("phaser"), require("underscore"));
	else if(typeof define === 'function' && define.amd)
		define(["phaser", "underscore"], factory);
	else if(typeof exports === 'object')
		exports["PhaserComps"] = factory(require("phaser"), require("underscore"));
	else
		root["PhaserComps"] = factory(root["Phaser"], root["_"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_phaser__, __WEBPACK_EXTERNAL_MODULE_underscore__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://PhaserComps/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/clip/ComponentClip.js":
/*!***********************************!*\
  !*** ./src/clip/ComponentClip.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! phaser */ \"phaser\");\n\nvar _underscore = __webpack_require__(/*! underscore */ \"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TYPE_IMAGE = 'image';\nvar TYPE_COMPONENT = 'component';\nvar TYPE_TEXT = 'text';\nvar TYPE_TILE_SPRITE = 'tileSprite';\nvar TYPE_POLYGON = 'polygon';\nvar TYPE_ZONE = 'zone';\n\n/**\r\n * @typedef {Object} PhaserComps.ComponentClip.StateConfig\r\n * Component state config object, generated by jsfl exporter\r\n * @memberOf PhaserComps.ComponentClip\r\n * @property {number} [x=0] x coordinate of component\r\n * @property {number} [y=0] y coordinate of component\r\n * @property {number} [scaleX=1] x scale of component\r\n * @property {number} [scaleY=1] y scale of component\r\n * @property {number} [angle=0] angle of component\r\n * @property {Number} [alpha=1] Opacity of component (`0` to `1`).\r\n */\n\n/**\r\n * @typedef {Object} PhaserComps.ComponentClip.ComponentConfig\r\n * @description\r\n * Component Config object, generated by jsfl exporter\r\n * @memberOf PhaserComps.ComponentClip\r\n * @property {String} type supported types are\r\n * `image`, `component`, `text`, `tileSprite`, `polygon`, `zone`\r\n * @property {Array<PhaserComps.ComponentClip.ComponentConfig>} [children] component children list\r\n * @property {String} [childId] unique component id, used by {@link StateManager}\r\n * @property {String} [key] key of component to find it with {@link UIComponentPrototype}.\r\n * Must be unique inside one state\r\n * @property {String} [image] Texture frame name. Only for component types `image` and `tileSprite`\r\n * @property {Phaser.GameObjects.TextStyle} [style] text style object, used only for `text` type\r\n * @property {Object<String, PhaserComps.ComponentClip.StateConfig>} [states] object keys are component ids to be enabled\r\n * at the specified state, and the StateConfig is position and scale params to setup for component\r\n * @property {Array<String>} masking List of component ids, that will be masked by this component.\r\n * Currently only polygon masks available.\r\n * @property {Number} [x=0] x coordinate of component\r\n * @property {Number} [y=0] y coordinate of component\r\n * @property {Number} [scaleX=1] x scale of component\r\n * @property {Number} [scaleY=1] y scale of component\r\n * @property {Number} [angle=0] angle of component in degrees\r\n * @property {Number} [alpha=1] Opacity of component (`0` to `1`).\r\n * @property {Number} [width] Component width.\r\n * only for `zone` type\r\n * @property {Number} [height] Component height.\r\n * only for `zone` type\r\n * @property {Array.<Number>} [vertices] Array of polygon vertices coords, `x` and `y` interleaving.\r\n * Only for `polygon` type\r\n * @property {int} [color] polygon color.\r\n * Only for `polygon` type\r\n */\n\n/**\r\n * @class ComponentClip\r\n * @memberOf PhaserComps\r\n * @classdesc\r\n * Component clip is a group of Phaser GameObjects and child ComponentClips.\r\n * Builds itself with provided jsfl-generated config object.\r\n *\r\n * Clip supports state switching. Best if controlled by\r\n * [UIComponentPrototype]{@link PhaserComps.UIComponents.UIComponentPrototype} instance\r\n *\r\n * *Note! do not change `x`, `y`, `scaleX`, `scaleY`, `angle`, `alpha`, `visible` properties of clip instance.*\r\n *\r\n * *If you need to move, scale, rotate, change alpha and visibility of the clip group, use*\r\n * *`groupX`, `groupY`, `groupScaleX`, `groupScaleY`, `groupAngle`, `groupAlpha`, `groupVisible` properties*\r\n *\r\n * @property {Number} [groupX=0] clip group position x\r\n * @property {Number} [groupY=0] clip group position x\r\n * @property {Number} [groupAlpha=1] clip group alpha\r\n * @property {Number} [groupScaleX=1] clip group scaleX\r\n * @property {Number} [groupScaleY=1] clip group scaleY\r\n * @property {Number} [groupAngle=0] clip group angle in degrees.\r\n * Note, that every group child will be rotated around its own origin\r\n * @property {Boolean} [groupVisible=true] clip group visibility flag\r\n *\r\n *\r\n * @property {Number} x **only for private usage**, if you want to move clip manually, use `groupX`\r\n * @property {Number} y **only for private usage**, if you want to move clip manually, use `groupY`\r\n * @property {Number} scaleX **only for private usage**, if you want to scale clip manually, use `groupScaleX`\r\n * @property {Number} scaleY **only for private usage**, if you want to scale clip manually, use `groupScaleY`\r\n * @property {Number} alpha **only for private usage**, if you want to change clip alpha manually, use `groupAlpha`.\r\n * @property {Number} angle **only for private usage**, if you want to rotate clip manually, use `groupAngle`.\r\n * @property {Boolean} visible **only for private usage**, if you want to switch clip visibility manually,\r\n * use `groupVisible`\r\n\r\n * @see PhaserComps.UIComponents.UIComponentPrototype\r\n *\r\n * @param {Phaser.Scene} scene Phaser scene to create component at\r\n * @param {ComponentConfig} config jsfl-generated config object\r\n * @param {Array<String>} textures Array of texture names, where component should find its texture frames\r\n * @param {Boolean} [isChildComponent = false] used internally to build child component clips recursively\r\n */\n\nvar ComponentClip = function () {\n\tfunction ComponentClip(scene, config, textures, isChildComponent) {\n\t\t_classCallCheck(this, ComponentClip);\n\n\t\tthis.scene = scene;\n\n\t\tthis.childrenList = [];\n\n\t\tthis._groupConfig = {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tscaleX: 1,\n\t\t\tscaleY: 1,\n\t\t\tangle: 0,\n\t\t\talpha: 1,\n\t\t\tvisible: true\n\t\t};\n\n\t\tthis._x = 0;\n\t\tthis._y = 0;\n\t\tthis._scaleX = 1;\n\t\tthis._scaleY = 1;\n\t\tthis._angle = 0;\n\t\tthis._angle = 0;\n\t\tthis._alpha = 1;\n\t\tthis._visible = true;\n\n\t\tthis._isChildComponent = isChildComponent || false;\n\t\tif (this._isChildComponent) {\n\t\t\tthis._container = scene.add.container(0, 0);\n\t\t\tthis.childrenList.push(this._container);\n\t\t}\n\t\t/**\r\n   * component config object\r\n   * @type {Object}\r\n   * */\n\t\tthis._config = config;\n\n\t\t/**\r\n   * component key\r\n   * @type {String}\r\n   */\n\t\tthis._key = config.key;\n\n\t\t/**\r\n   * list of texture names to use in this component\r\n   * @type {Array<String>}\r\n   * */\n\t\tthis._textures = textures;\n\n\t\t/**\r\n   * Texture frames to texture names map\r\n   * @type {Object<String>}\r\n   */\n\t\tthis.imageFramesMap = {};\n\n\t\t/**\r\n   * Component's state manager instance. Helps to switch states and find active children by key\r\n   * @type {StateManager}\r\n   * */\n\t\tthis._stateManager = new StateManager(this, config);\n\n\t\tthis._childrenById = {};\n\n\t\tthis._createImagesMap(textures);\n\t\tthis._parseConfig();\n\t}\n\n\t_createClass(ComponentClip, [{\n\t\tkey: 'setMask',\n\t\tvalue: function setMask(mask) {\n\t\t\t_underscore2.default.each(this.childrenList, function (child) {\n\t\t\t\tchild.setMask(mask);\n\t\t\t}, this);\n\t\t}\n\n\t\t/**\r\n   * @public\r\n   * @method PhaserComps.ComponentClip#setState\r\n   * @description\r\n   * Switch component view to specified stateId, if such stateId exists.\r\n   * Do not use it manually, if you are using ComponentPrototype to control the view\r\n   *\r\n   * @param {String} stateId state id to switch to\r\n   * @param {Boolean} [force=false] if true, state will be setup again even if stateId was not changed\r\n   */\n\n\t}, {\n\t\tkey: 'setState',\n\t\tvalue: function setState(stateId, force) {\n\t\t\tthis._stateManager.setState(stateId, force);\n\t\t}\n\n\t\t/**\r\n   * @public\r\n   * @method PhaserComps.ComponentClip#getChildClip\r\n   * @description returns current active component child view instance\r\n   * @param {String} key child key\r\n   * @returns {PhaserComps.ComponentClip|Phaser.GameObjects.GameObject}\r\n   */\n\n\t}, {\n\t\tkey: 'getChildClip',\n\t\tvalue: function getChildClip(key) {\n\t\t\treturn this._stateManager.getActiveComponentByKey(key);\n\t\t}\n\n\t\t/**\r\n   * @public\r\n   * @method PhaserComps.ComponentClip#getChildText\r\n   * @description returns current active component child text instance\r\n   * @param {String} key child text field key\r\n   * @returns {Phaser.GameObjects.Text}\r\n   */\n\n\t}, {\n\t\tkey: 'getChildText',\n\t\tvalue: function getChildText(key) {\n\t\t\t// TODO separate getter\n\t\t\treturn this._stateManager.getActiveComponentByKey(key);\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_createImagesMap\r\n   * @description\r\n   * Fill the imageFramesMap object from provided textures.\r\n   * imageFramesMap used to\r\n   * @param {Array<String>} textures\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createImagesMap',\n\t\tvalue: function _createImagesMap(textures) {\n\t\t\tvar _this = this;\n\n\t\t\t_underscore2.default.each(textures, function (textureName) {\n\t\t\t\tvar texture = _this.scene.textures.get(textureName);\n\t\t\t\tif (!texture) return;\n\t\t\t\tvar frames = texture.getFrameNames();\n\t\t\t\t_underscore2.default.each(frames, function (frameName) {\n\t\t\t\t\t_this.imageFramesMap[frameName] = textureName;\n\t\t\t\t}, _this);\n\t\t\t}, this);\n\t\t}\n\t}, {\n\t\tkey: '_parseConfig',\n\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_parseConfig\r\n   * @description\r\n   * Builds component from config\r\n   * @private\r\n   * @ignore\r\n   */\n\t\tvalue: function _parseConfig() {\n\t\t\tvar _this2 = this;\n\n\t\t\t//ComponentView._setupCommonParams(this, this._config);\n\t\t\tif (this._config.hasOwnProperty('children')) {\n\t\t\t\t_underscore2.default.each(this._config.children, function (childConfig) {\n\t\t\t\t\t_this2._createChildFromConfig(childConfig);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_createChildFromConfig\r\n   * @description creates child instance, depending on its type, add it to state manager\r\n   * @param {ComponentConfig} config child component config object\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createChildFromConfig',\n\t\tvalue: function _createChildFromConfig(config) {\n\t\t\tvar _this3 = this;\n\n\t\t\tvar child = null;\n\t\t\tvar childView = null;\n\t\t\tvar childId = config.childId;\n\t\t\tvar childKey = config.key;\n\t\t\tif (config.type === TYPE_IMAGE) {\n\t\t\t\tchild = this._createImageFromConfig(config);\n\t\t\t} else if (config.type === TYPE_TEXT) {\n\t\t\t\tchild = this._createTextFromConfig(config);\n\t\t\t} else if (config.type === TYPE_TILE_SPRITE) {\n\t\t\t\tchild = this._createTileSpriteFromConfig(config);\n\t\t\t} else if (config.type === TYPE_COMPONENT) {\n\t\t\t\tchild = new ComponentClip(this.scene, config, this._textures, true);\n\t\t\t\tComponentClip._setupCommonParams(child, config);\n\t\t\t\tchildView = child._container;\n\t\t\t} else if (config.type === TYPE_ZONE) {\n\t\t\t\tchild = this._createHitZoneFromConfig(config);\n\t\t\t} else if (config.type === TYPE_POLYGON) {\n\t\t\t\tchild = this._createPolygonFromConfig(config);\n\t\t\t}\n\t\t\tif (childView === null) childView = child;\n\n\t\t\tif (child === null) {\n\t\t\t\tconsole.warn('unknown component type', config.type, config);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//ComponentView._setupCommonParams(child, config);\n\t\t\tthis._childrenById[childId] = child;\n\t\t\tif (config.hasOwnProperty('masking')) {\n\t\t\t\t// TODO check if the shape\n\t\t\t\tvar mask = child.createGeometryMask();\n\t\t\t\t_underscore2.default.each(config.masking, function (maskedChildId) {\n\t\t\t\t\tvar maskedChild = _this3._childrenById[maskedChildId];\n\t\t\t\t\tmaskedChild.setMask(mask);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\tif (this._isChildComponent) {\n\t\t\t\tthis._container.add(childView);\n\t\t\t} else {\n\t\t\t\tthis.childrenList.push(child);\n\t\t\t}\n\t\t\tthis._stateManager.addComponent(child, childId, childKey);\n\t\t}\n\n\t\t/**\r\n   * @description Create simple polygon with provided vertices from config\r\n   * @method PhaserComps.ComponentClip#_createPolygonFromConfig\r\n   * @param {ComponentConfig} config\r\n   * @returns {Phaser.GameObjects.Graphics}\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createPolygonFromConfig',\n\t\tvalue: function _createPolygonFromConfig(config) {\n\t\t\tvar shape = this.scene.make.graphics();\n\t\t\t// TODO FIXME fillStyle color from config\n\t\t\tshape.fillStyle(config.color, config.hasOwnProperty('alpha') ? config.alpha : 1);\n\t\t\tshape.beginPath();\n\t\t\tshape.beginPath();\n\t\t\tfor (var i = 0; i < config.vertices.length; i += 2) {\n\t\t\t\tshape.lineTo(config.vertices[i], config.vertices[i + 1]);\n\t\t\t}\n\t\t\tshape.fillPath();\n\t\t\tshape.closePath();\n\t\t\tComponentClip._setupCommonParams(shape, config);\n\t\t\tif (!config.hasOwnProperty('masking')) this.scene.add.existing(shape);\n\t\t\treturn shape;\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_createTileSpriteFromConfig\r\n   * @description creates Phaser.GameObjects.TileSprite by jsfl-generated config and returns it\r\n   * @param {Object} config jsfl-generated TileSprite config object\r\n   * @returns {Phaser.GameObjects.TileSprite}\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createTileSpriteFromConfig',\n\t\tvalue: function _createTileSpriteFromConfig(config) {\n\t\t\tvar sprite = this.scene.add.tileSprite(0, 0, config.width, config.height, this.imageFramesMap[config.image], config.image);\n\t\t\tsprite.setOrigin(0.5, 0.5); // Animate places shape coords to center\n\t\t\tComponentClip._setupCommonParams(sprite, config);\n\t\t\treturn sprite;\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_createImageFromConfig\r\n   * @description creates Phaser.GameObjects.Image instance by jsfl-generated config and returns it\r\n   * @param {Object} config jsfl-generated Image config object\r\n   * @returns {Phaser.GameObjects.Image}\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createImageFromConfig',\n\t\tvalue: function _createImageFromConfig(config) {\n\t\t\tvar image = this.scene.add.image(0, 0, this.imageFramesMap[config.image], config.image);\n\t\t\timage.setOrigin(0);\n\t\t\tComponentClip._setupCommonParams(image, config);\n\t\t\treturn image;\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_createTextFromConfig\r\n   * @description creates Phaser.GameObjects.Text instance by jsfl-generated config and returns it\r\n   * @param {Object} config jsfl-generated Text config object\r\n   * @returns {Phaser.GameObjects.Text}\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createTextFromConfig',\n\t\tvalue: function _createTextFromConfig(config) {\n\t\t\tvar text = this.scene.add.text(0, 0, config.text, config.textStyle);\n\t\t\tif (config.textStyle.align === 'center') {\n\t\t\t\ttext.setOrigin(0.5, 0);\n\t\t\t} else if (config.textStyle.align === 'right') {\n\t\t\t\ttext.setOrigin(1, 0);\n\t\t\t} else {\n\t\t\t\ttext.setOrigin(0);\n\t\t\t}\n\t\t\tComponentClip._setupCommonParams(text, config);\n\t\t\treturn text;\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.ComponentClip#_createHitZoneFromConfig\r\n   * @description creates Phaser.GameObjects.Zone instance by jsfl-generated config and returns it\r\n   * @param {Object} config jsfl-generated Zone config object\r\n   * @return {Phaser.GameObjects.Zone}\r\n   * @private\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: '_createHitZoneFromConfig',\n\t\tvalue: function _createHitZoneFromConfig(config) {\n\t\t\treturn this.scene.add.zone(config.x || 0, config.y || 0, config.width, config.height).setOrigin(0);\n\t\t}\n\n\t\t/**\r\n   * @memberOf ComponentClip\r\n   * @description setup common game object params from jsfl-generated config\r\n   * @param {*} component\r\n   * @param {Object} config\r\n   * @param {Object} [groupConfig]\r\n   * @ignore\r\n   */\n\n\t}, {\n\t\tkey: 'groupX',\n\t\tget: function get() {\n\t\t\treturn this._groupConfig.x;\n\t\t},\n\t\tset: function set(val) {\n\t\t\t//debugger;\n\t\t\tif (this._groupConfig.x === val) return;\n\t\t\tvar delta = val - this._groupConfig.x;\n\t\t\tthis._groupConfig.x = val;\n\t\t\tthis.x += delta;\n\t\t}\n\t}, {\n\t\tkey: 'groupY',\n\t\tget: function get() {\n\t\t\treturn this._groupConfig.y;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._groupConfig.y === val) return;\n\t\t\tvar delta = val - this._groupConfig.y;\n\t\t\tthis._groupConfig.y = val;\n\t\t\tthis.y += delta;\n\t\t}\n\t}, {\n\t\tkey: 'groupScaleX',\n\t\tget: function get() {\n\t\t\treturn this._groupConfig.scaleX;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._groupConfig.scaleX === val) return;\n\t\t\tvar delta = val / this._groupConfig.scaleX;\n\t\t\tthis._groupConfig.scaleX = val;\n\t\t\tthis.scaleX *= delta;\n\t\t}\n\t}, {\n\t\tkey: 'groupScaleY',\n\t\tget: function get() {\n\t\t\treturn this._groupConfig.scaleY;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._groupConfig.scaleY === val) return;\n\t\t\tvar delta = val / this._groupConfig.scaleY;\n\t\t\tthis._groupConfig.scaleY = val;\n\t\t\tthis.scaleY *= delta;\n\t\t}\n\t}, {\n\t\tkey: 'groupAlpha',\n\t\tget: function get() {\n\t\t\treturn this._groupConfig.alpha;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._groupConfig.alpha === val) return;\n\t\t\tvar delta = val / this._groupConfig.alpha;\n\t\t\tthis._groupConfig.alpha = val;\n\t\t\tthis.alpha *= delta;\n\t\t}\n\t}, {\n\t\tkey: 'groupVisible',\n\t\tget: function get() {\n\t\t\treturn this._groupConfig.visible;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._groupConfig.visible === val) return;\n\t\t\tthis._groupConfig.visible = val;\n\t\t\tthis.visible &= val;\n\t\t}\n\t}, {\n\t\tkey: 'x',\n\t\tget: function get() {\n\t\t\treturn this._x;\n\t\t},\n\t\tset: function set(val) {\n\t\t\t//if (this.x === val) return;\n\t\t\tvar delta = val - this.x;\n\t\t\tPhaser.Actions.IncX(this.childrenList, delta);\n\t\t\tthis._x = val;\n\t\t}\n\t}, {\n\t\tkey: 'y',\n\t\tget: function get() {\n\t\t\treturn this._y;\n\t\t},\n\t\tset: function set(val) {\n\t\t\t//if (this.y === val) return;\n\t\t\tvar delta = val - this.y;\n\t\t\tPhaser.Actions.IncY(this.childrenList, delta);\n\t\t\tthis._y = val;\n\t\t}\n\t}, {\n\t\tkey: 'visible',\n\t\tget: function get() {\n\t\t\treturn this._visible;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._visible === val) return;\n\t\t\tthis._visible = val;\n\t\t\tPhaser.Actions.SetVisible(this.childrenList, val);\n\t\t}\n\t}, {\n\t\tkey: 'alpha',\n\t\tget: function get() {\n\t\t\treturn this._alpha;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._alpha === val) return;\n\t\t\tthis._alpha = val;\n\t\t\tPhaser.Actions.SetAlpha(this.childrenList, val);\n\t\t}\n\t}, {\n\t\tkey: 'scaleX',\n\t\tget: function get() {\n\t\t\treturn this._scaleX;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._scaleX === val) return;\n\t\t\tthis._scaleX = val;\n\t\t\tPhaser.Actions.SetScaleX(this.childrenList, val);\n\t\t}\n\t}, {\n\t\tkey: 'scaleY',\n\t\tget: function get() {\n\t\t\treturn this._scaleY;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._scaleY === val) return;\n\t\t\tthis._scaleY = val;\n\t\t\tPhaser.Actions.SetScaleY(this.childrenList, val);\n\t\t}\n\t}, {\n\t\tkey: 'angle',\n\t\tget: function get() {\n\t\t\treturn this._angle;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._angle === val) return;\n\t\t\tPhaser.Actions.PropertyValueSet(this.childrenList, 'angle', val);\n\t\t}\n\t}], [{\n\t\tkey: '_setupCommonParams',\n\t\tvalue: function _setupCommonParams(component, config, groupConfig) {\n\t\t\tcomponent.x = (config.x || 0) + (groupConfig ? groupConfig.x : 0);\n\t\t\tcomponent.y = (config.y || 0) + (groupConfig ? groupConfig.y : 0);\n\t\t\tcomponent.scaleX = (config.scaleX || 1) * (groupConfig ? groupConfig.scaleX : 1);\n\t\t\tcomponent.scaleY = (config.scaleY || 1) * (groupConfig ? groupConfig.scaleY : 1);\n\t\t\tcomponent.angle = (config.angle || 0) + (groupConfig ? groupConfig.angle : 0);\n\t\t\tcomponent.alpha = (config.hasOwnProperty('alpha') ? config.alpha : 1) * (groupConfig ? groupConfig.alpha : 1);\n\t\t}\n\t}]);\n\n\treturn ComponentClip;\n}();\n\nexports.default = ComponentClip;\n\nvar StateManager = function () {\n\t/**\r\n  * @class StateManager\r\n  * @memberOf PhaserComps.ComponentClip\r\n  * @classdesc\r\n  * For [ComponentClip]{@link PhaserComps.ComponentClip}\r\n  * internal use only\r\n  *\r\n  * Shows or hides component view instances depending on which state is active.\r\n  * Helps to get current active components by keys.\r\n  *\r\n  * @param {Object} config Main component states config object\r\n  *\r\n  */\n\tfunction StateManager(view, config) {\n\t\t_classCallCheck(this, StateManager);\n\n\t\tthis._view = view;\n\n\t\t/**\r\n   *\r\n   * @type {Array<String>}\r\n   * @private\r\n   */\n\t\tthis._dynamicChildrenIds = [];\n\n\t\t/**\r\n   *\r\n   * @type {Object<State>}\r\n   * @private\r\n   */\n\t\tthis._states = {};\n\n\t\t/**\r\n   *\r\n   * @type {Object}\r\n   * @private\r\n   */\n\t\tthis._components = {};\n\n\t\t/**\r\n   *\r\n   * @type {State}\r\n   * @private\r\n   */\n\t\tthis._currentState = null;\n\n\t\t/**\r\n   *\r\n   * @type {String}\r\n   * @private\r\n   */\n\n\t\tthis._currentStateId = null;\n\t\t/**\r\n   *\r\n   * @type {Object<String>}\r\n   * @private\r\n   */\n\t\tthis._componentKeys = {};\n\n\t\tthis._residentComponentsByKey = {};\n\t\tvar idsArrays = [];\n\t\tfor (var stateId in config.states) {\n\t\t\tvar state = new State(config.states[stateId]);\n\t\t\tthis._states[stateId] = state;\n\t\t\tidsArrays.push(state.componentIds);\n\t\t}\n\t\tthis._dynamicChildrenIds = _underscore2.default.uniq(_underscore2.default.flatten(idsArrays));\n\t}\n\n\t/**\r\n  * @method PhaserComps.ComponentClip.StateManager#addComponent\r\n  * @param {PhaserComps.ComponentClip|Phaser.GameObjects.GameObject} component\r\n  * component view instance, it may be text, image, sprite, or ComponentView instance\r\n  * @param {String} childId unique child id from component config\r\n  * @param {String} [childKey] child key from component config\r\n  */\n\n\n\t_createClass(StateManager, [{\n\t\tkey: 'addComponent',\n\t\tvalue: function addComponent(component, childId, childKey) {\n\n\t\t\tif (_underscore2.default.indexOf(this._dynamicChildrenIds, childId) === -1) {\n\t\t\t\tif (childKey !== undefined) this._residentComponentsByKey[childKey] = component;\n\t\t\t} else {\n\t\t\t\tthis._components[childId] = component;\n\t\t\t\tif (childKey !== undefined) this._componentKeys[childId] = childKey;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Setup state with provided stateId, if exists\r\n   * @method PhaserComps.ComponentClip.StateManager#setState\r\n   * @param {String} stateId state id to setup\r\n   * @param {Boolean} force if true, update state even if stateId was not changed\r\n   */\n\n\t}, {\n\t\tkey: 'setState',\n\t\tvalue: function setState(stateId, force) {\n\t\t\tif (this._currentStateId === stateId && !force) return;\n\t\t\tif (!this._states.hasOwnProperty(stateId)) return;\n\t\t\tthis._currentStateId = stateId;\n\t\t\tthis._currentState = this._states[stateId];\n\t\t\tthis._setupState();\n\t\t}\n\n\t\t/**\r\n   * Get component with provided key, if exists and is present in current state\r\n   * @method PhaserComps.ComponentClip.StateManager#getActiveComponentByKey\r\n   * @param {String} key Component key to get\r\n   * @returns {ComponentClip|Phaser.GameObjects.Image|Phaser.GameObjects.TileSprite|Phaser.GameObjects.Text|null}\r\n   */\n\n\t}, {\n\t\tkey: 'getActiveComponentByKey',\n\t\tvalue: function getActiveComponentByKey(key) {\n\t\t\tif (this._residentComponentsByKey.hasOwnProperty(key)) return this._residentComponentsByKey[key];\n\t\t\tif (this._currentState === null) return null;\n\t\t\tfor (var i in this._currentState.componentIds) {\n\t\t\t\tvar id = this._currentState.componentIds[i];\n\t\t\t\tif (this._componentKeys[id] === key) {\n\t\t\t\t\treturn this._components[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\r\n   * Show state components, apply its' state positions, and hide non-state components\r\n   * @method PhaserComps.ComponentClip.tateManager#_setupState\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_setupState',\n\t\tvalue: function _setupState() {\n\t\t\tvar _this4 = this;\n\n\t\t\tvar idsToShow = this._currentState.componentIds;\n\t\t\tvar idsToHide = _underscore2.default.difference(this._dynamicChildrenIds, idsToShow);\n\n\t\t\t_underscore2.default.each(idsToHide, function (id) {\n\t\t\t\t_this4._components[id].visible = false;\n\t\t\t}, this);\n\n\t\t\t_underscore2.default.each(idsToShow, function (id) {\n\t\t\t\tvar component = _this4._components[id];\n\t\t\t\tcomponent.visible = _this4._view._groupConfig.visible; // && true;\n\t\t\t\tComponentClip._setupCommonParams(component, _this4._currentState.config[id], _this4._view._groupConfig);\n\t\t\t}, this);\n\t\t}\n\t}]);\n\n\treturn StateManager;\n}();\n\nvar State =\n/**\r\n * @class State\r\n * @classdesc State config decorator, for\r\n * [StateManager]{@link PhaserComps.ComponentClip.StateManager} internal use only\r\n * @param {PhaserComps.ComponentClip.StateConfig} config\r\n * @memberOf PhaserComps.ComponentClip\r\n */\nfunction State(config) {\n\t_classCallCheck(this, State);\n\n\t/**\r\n  * State config object\r\n  * @type {PhaserComps.ComponentClip.StateConfig}\r\n  */\n\tthis.config = config;\n\t/**\r\n  * Component ids, that are only active in this state\r\n  * @type {Array<String>}\r\n  */\n\tthis.componentIds = [];\n\tfor (var componentId in config) {\n\t\tthis.componentIds.push(componentId);\n\t}\n};\n\n//# sourceURL=webpack://PhaserComps/./src/clip/ComponentClip.js?");

/***/ }),

/***/ "./src/components/UIButton.js":
/*!************************************!*\
  !*** ./src/components/UIButton.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _UIComponentPrototype2 = __webpack_require__(/*! ./UIComponentPrototype */ \"./src/components/UIComponentPrototype.js\");\n\nvar _UIComponentPrototype3 = _interopRequireDefault(_UIComponentPrototype2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar HIT_ZONE = 'HIT_ZONE';\n\nvar LABEL = 'label';\n\nvar _STATE_UP = \"up\";\nvar _STATE_DOWN = \"down\";\nvar _STATE_OVER = \"over\";\nvar _STATE_DISABLE = \"disable\";\n\nvar _EVENT_CLICK = \"event_click\";\n\n/**\r\n * @memberOf UIComponents\r\n * @class UIButton\r\n * @classdesc\r\n * Button component prototype, has states `up`, `over`, `down`, `disable`\r\n * Emits EVENT_CLICK on click.\r\n * When disabled, doesn't interact to mouse events and move to state `disable`\r\n * @extends UIComponentPrototype\r\n * @emits EVENT_CLICK\r\n *\r\n * @property {Boolean} enable activate/deactivate button interaction. if false, button state is set to `disable`\r\n * @property {String} label get/set button label text\r\n *\r\n * @param {UIComponentPrototype} [parent]\r\n * @param {String} [key]\r\n * @param {String} [labelText]\r\n */\n\nvar UIButton = function (_UIComponentPrototype) {\n\t_inherits(UIButton, _UIComponentPrototype);\n\n\t_createClass(UIButton, null, [{\n\t\tkey: 'EVENT_CLICK',\n\n\n\t\t/**\r\n   * @event UIComponents.UIButton.EVENT_CLICK\r\n   * @memberOf UIComponents.UIButton\r\n   * @description\r\n   * Emitted on click by\r\n   */\n\t\tget: function get() {\n\t\t\treturn _EVENT_CLICK;\n\t\t}\n\t}]);\n\n\tfunction UIButton(parent, key, labelText) {\n\t\t_classCallCheck(this, UIButton);\n\n\t\tvar _this = _possibleConstructorReturn(this, (UIButton.__proto__ || Object.getPrototypeOf(UIButton)).call(this, parent, key));\n\n\t\t_this._enable = true;\n\t\t_this._isPressed = false;\n\t\t_this._isOver = false;\n\t\tif (labelText !== undefined && labelText !== null) _this.label = labelText;\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * @method UIComponents.UIButton#onClipAppend\r\n  * @inheritDoc\r\n  */\n\n\n\t_createClass(UIButton, [{\n\t\tkey: 'onClipAppend',\n\t\tvalue: function onClipAppend(clip) {\n\t\t\tthis._updateInteractive();\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButton#onClipRemove\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: 'onClipRemove',\n\t\tvalue: function onClipRemove(clip) {\n\t\t\tvar zone = clip.getChildClip(HIT_ZONE);\n\t\t\tif (!zone) {\n\t\t\t\t//console.warn('no hit zone for', this._key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._removeInteractive(zone);\n\t\t}\n\t}, {\n\t\tkey: '_setupInteractive',\n\n\n\t\t/**\r\n   * @method UIButton#_setupInteractive\r\n   * @param {Phaser.GameObjects.Zone} zone\r\n   * @private\r\n   */\n\t\tvalue: function _setupInteractive(zone) {\n\t\t\tzone.setInteractive({ useHandCursor: true });\n\t\t\tzone.on('pointerdown', this._onPointerDown, this);\n\t\t\tzone.on('pointerup', this._onPointerUp, this);\n\t\t\tzone.on('pointerover', this._onPointerOver, this);\n\t\t\tzone.on('pointerout', this._onPointerOut, this);\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButton#_removeInteractive\r\n   * @param {Phaser.GameObjects.Zone} zone\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_removeInteractive',\n\t\tvalue: function _removeInteractive(zone) {\n\t\t\tzone.disableInteractive();\n\t\t\tzone.removeListener('pointerdown', this._onPointerDown, this);\n\t\t\tzone.removeListener('pointerup', this._onPointerUp, this);\n\t\t\tzone.removeListener('pointerover', this._onPointerOver, this);\n\t\t\tzone.removeListener('pointerout', this._onPointerOut, this);\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButton#_updateInteractive\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_updateInteractive',\n\t\tvalue: function _updateInteractive() {\n\t\t\tif (!this._clip) return;\n\t\t\tvar zone = this._clip.getChildClip(HIT_ZONE);\n\t\t\tif (!zone) {\n\t\t\t\t//console.warn('no hit zone for', this._key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.enable) {\n\t\t\t\tthis._setupInteractive(zone);\n\t\t\t} else {\n\t\t\t\tthis._removeInteractive(zone);\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButton#getStateId\r\n   * @inheritDoc\r\n   * @returns {String}\r\n   */\n\n\t}, {\n\t\tkey: 'getStateId',\n\t\tvalue: function getStateId() {\n\t\t\tif (!this.enable) return this.STATE_DISABLE;\n\t\t\tif (this._isPressed) return this.STATE_DOWN;\n\t\t\tif (this._isOver) return this.STATE_OVER;\n\t\t\treturn this.STATE_UP;\n\t\t}\n\n\t\t/**\r\n   * @protected\r\n   * @method UIComponents.UIButton#_onClick\r\n   * @description\r\n   * called when button hit zone clicked, emits EVENT_CLICK\r\n   */\n\n\t}, {\n\t\tkey: '_onClick',\n\t\tvalue: function _onClick() {\n\t\t\tthis.emit(_EVENT_CLICK);\n\t\t}\n\t}, {\n\t\tkey: '_onPointerOut',\n\n\n\t\t/**\r\n   * @method UIButton#_onPointerOut\r\n   * @protected\r\n   */\n\t\tvalue: function _onPointerOut() {\n\t\t\tthis._isOver = false;\n\t\t\tthis._isPressed = false;\n\t\t\tthis.doState();\n\t\t}\n\n\t\t/**\r\n   * @method UIButton#_onPointerOver\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: '_onPointerOver',\n\t\tvalue: function _onPointerOver() {\n\t\t\tthis._isOver = true;\n\t\t\tthis.doState();\n\t\t}\n\n\t\t/**\r\n   * @method UIButton#_onPointerDown\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: '_onPointerDown',\n\t\tvalue: function _onPointerDown() {\n\t\t\tthis._isPressed = true;\n\t\t\tthis.doState();\n\t\t}\n\n\t\t/**\r\n   * @method UIButton#_onPointerUp\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: '_onPointerUp',\n\t\tvalue: function _onPointerUp() {\n\t\t\tvar isClicked = this._isPressed && this._isOver;\n\t\t\tthis._isPressed = false;\n\t\t\tthis.doState();\n\t\t\tif (isClicked) this._onClick();\n\t\t}\n\n\t\t/**\r\n   * @method UIButton#destroy\r\n   * @protected\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tif (this._clip) {\n\t\t\t\tvar zone = this._clip.getChildClip(HIT_ZONE);\n\t\t\t\tif (zone) {\n\t\t\t\t\tthis._removeInteractive(zone);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_get(UIButton.prototype.__proto__ || Object.getPrototypeOf(UIButton.prototype), 'destroy', this).call(this);\n\t\t}\n\t}, {\n\t\tkey: 'label',\n\t\tget: function get() {\n\t\t\treturn this.getText(LABEL);\n\t\t},\n\t\tset: function set(value) {\n\t\t\tthis.setText(LABEL, value);\n\t\t}\n\t}, {\n\t\tkey: 'enable',\n\t\tget: function get() {\n\t\t\treturn this._enable;\n\t\t},\n\t\tset: function set(value) {\n\t\t\tif (this._enable === value) return;\n\t\t\tthis._enable = value;\n\t\t\tthis._updateInteractive();\n\t\t\tthis.doState();\n\t\t}\n\t}, {\n\t\tkey: 'STATE_UP',\n\t\tget: function get() {\n\t\t\treturn _STATE_UP;\n\t\t}\n\t}, {\n\t\tkey: 'STATE_DOWN',\n\t\tget: function get() {\n\t\t\treturn _STATE_DOWN;\n\t\t}\n\t}, {\n\t\tkey: 'STATE_OVER',\n\t\tget: function get() {\n\t\t\treturn _STATE_OVER;\n\t\t}\n\t}, {\n\t\tkey: 'STATE_DISABLE',\n\t\tget: function get() {\n\t\t\treturn _STATE_DISABLE;\n\t\t}\n\t}]);\n\n\treturn UIButton;\n}(_UIComponentPrototype3.default);\n\nexports.default = UIButton;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIButton.js?");

/***/ }),

/***/ "./src/components/UIButtonDraggable.js":
/*!*********************************************!*\
  !*** ./src/components/UIButtonDraggable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _UIButton2 = __webpack_require__(/*! ./UIButton */ \"./src/components/UIButton.js\");\n\nvar _UIButton3 = _interopRequireDefault(_UIButton2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _EVENT_DRAG = 'event_drag';\n\nvar UIButtonDraggable = function (_UIButton) {\n\t_inherits(UIButtonDraggable, _UIButton);\n\n\t_createClass(UIButtonDraggable, null, [{\n\t\tkey: 'EVENT_DRAG',\n\n\n\t\t/**\r\n   * @typedef DragBounds\r\n   * @memberOf UIComponents.UIButtonDraggable\r\n   * @property {Number} minX left drag bound\r\n   * @property {Number} minY top drag bound\r\n   * @property {Number} maxX right drag bound\r\n   * @property {Number} maxY bottom drag bound\r\n   */\n\n\t\t/**\r\n   * @event UIComponents.UIButtonDraggable.EVENT_DRAG\r\n   * @memberOf UIComponents.UIButtonDraggable\r\n   * @description\r\n   * Emitted on drag move.\r\n   * @param {Number} x horizontal drag movement (from drag start)\r\n   * @param {Number} y  vertical drag movement (from drag start)\r\n   */\n\t\tget: function get() {\n\t\t\treturn _EVENT_DRAG;\n\t\t}\n\n\t\t/**\r\n   * @class UIButtonDraggable\r\n   * @memberOf UIComponents\r\n   * @classdesc\r\n   * Same as {@link UIComponents.UIButton}, but also emits EVENT_DRAG with two arguments, horizontal and vertical movement delta\r\n   *\r\n   * @extends UIComponents.UIButton\r\n   * @emits EVENT_CLICK,\r\n   * @emits EVENT_DRAG,\r\n   *\r\n   * @property {Boolean} enable activate/deactivate button interaction. if false, button state is set to `disable`\r\n   * @property {String} label get/set button label text\r\n   *\r\n   * @param {UIComponentPrototype} [parent]\r\n   * @param {String} [key]\r\n   * @param {String} [labelText]\r\n   */\n\n\t}]);\n\n\tfunction UIButtonDraggable(parent, key, labelText) {\n\t\t_classCallCheck(this, UIButtonDraggable);\n\n\t\t/**\r\n   *\r\n   * @type DragBounds\r\n   * @private\r\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (UIButtonDraggable.__proto__ || Object.getPrototypeOf(UIButtonDraggable)).call(this, parent, key, labelText));\n\n\t\t_this._dragBounds = {\n\t\t\tminX: 0,\n\t\t\tmaxX: 0,\n\t\t\tminY: 0,\n\t\t\tmaxY: 0\n\t\t};\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._startDragX = 0;\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._startDragY = 0;\n\t\t/**\r\n   *\r\n   * @type {Phaser.GameObjects.Zone}\r\n   * @private\r\n   */\n\t\t_this._dragZone = null;\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * Set clip drag bounds\r\n  * @method UIComponents.UIButtonDraggable#setDragBounds\r\n  * @param {Number} minX left drag bound\r\n  * @param {Number} minY top drag bound\r\n  * @param {Number} maxX right drag bound\r\n  * @param {Number} maxY bottom drag bound\r\n  */\n\n\n\t_createClass(UIButtonDraggable, [{\n\t\tkey: 'setDragBounds',\n\t\tvalue: function setDragBounds(minX, minY, maxX, maxY) {\n\t\t\tthis._dragBounds.minX = minX;\n\t\t\tthis._dragBounds.maxX = maxX;\n\t\t\tthis._dragBounds.minY = minY;\n\t\t\tthis._dragBounds.maxY = maxY;\n\t\t}\n\n\t\t/**\r\n   * _dragZone `dragstart` event callback\r\n   * @method UIComponents.UIButtonDraggable#_onDragStart\r\n   * @param pointer\r\n   * @param {Phaser.GameObjects.GameObject} gameObject\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: '_onDragStart',\n\t\tvalue: function _onDragStart(pointer, gameObject) {\n\t\t\tif (!this._dragZone || this._dragZone !== gameObject) return;\n\t\t\tif (!this._clip) return;\n\t\t\tthis._startDragX = this._clip.x;\n\t\t\tthis._startDragY = this._clip.y;\n\t\t}\n\n\t\t/**\r\n   * _dragZone `drag` event callback\r\n   * @method UIComponents.UIButtonDraggable#_onDrag\r\n   * @param pointer\r\n   * @param {Phaser.GameObjects.GameObject} gameObject\r\n   * @param {Number} dragX\r\n   * @param {Number} dragY\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: '_onDrag',\n\t\tvalue: function _onDrag(pointer, gameObject, dragX, dragY) {\n\t\t\tif (!this._dragZone || this._dragZone !== gameObject) return;\n\t\t\tif (!this._clip) return;\n\t\t\tvar newX = this._startDragX + dragX;\n\t\t\tvar newY = this._startDragY + dragY;\n\t\t\tif (newX < this._dragBounds.minX) newX = this._dragBounds.minX;\n\t\t\tif (newX > this._dragBounds.maxX) newX = this._dragBounds.maxX;\n\n\t\t\tif (newY < this._dragBounds.minY) newY = this._dragBounds.minY;\n\t\t\tif (newY > this._dragBounds.maxY) newY = this._dragBounds.maxY;\n\n\t\t\tthis.emit(_EVENT_DRAG, newX, newY);\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButtonDraggable#_setupInteractive\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: '_setupInteractive',\n\t\tvalue: function _setupInteractive(zone) {\n\t\t\t_get(UIButtonDraggable.prototype.__proto__ || Object.getPrototypeOf(UIButtonDraggable.prototype), '_setupInteractive', this).call(this, zone);\n\t\t\tthis._dragZone = zone;\n\t\t\tzone.scene.input.dragDistanceThreshold = 3;\n\t\t\tzone.scene.input.setDraggable(zone, true);\n\t\t\tzone.scene.input.on('dragstart', this._onDragStart, this);\n\t\t\tzone.scene.input.on('drag', this._onDrag, this);\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButtonDraggable#_removeInteractive\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: '_removeInteractive',\n\t\tvalue: function _removeInteractive(zone) {\n\t\t\t_get(UIButtonDraggable.prototype.__proto__ || Object.getPrototypeOf(UIButtonDraggable.prototype), '_removeInteractive', this).call(this, zone);\n\t\t\tthis._dragZone = null;\n\t\t\tzone.scene.input.setDraggable(zone, false);\n\t\t\tzone.scene.input.removeListener('dragstart', this._onDragStart);\n\t\t\tzone.scene.input.removeListener('drag', this._onDrag);\n\t\t}\n\t}]);\n\n\treturn UIButtonDraggable;\n}(_UIButton3.default);\n\nexports.default = UIButtonDraggable;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIButtonDraggable.js?");

/***/ }),

/***/ "./src/components/UIButtonRadio.js":
/*!*****************************************!*\
  !*** ./src/components/UIButtonRadio.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _UIButtonSelect2 = __webpack_require__(/*! ./UIButtonSelect */ \"./src/components/UIButtonSelect.js\");\n\nvar _UIButtonSelect3 = _interopRequireDefault(_UIButtonSelect2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _EVENT_SELECT = 'event_select';\n\nvar UIButtonRadio = function (_UIButtonSelect) {\n\t_inherits(UIButtonRadio, _UIButtonSelect);\n\n\t_createClass(UIButtonRadio, null, [{\n\t\tkey: \"EVENT_SELECT\",\n\n\n\t\t/**\r\n   * Fired when some radio button of the group is selected\r\n   * @static\r\n   * @memberOf UIComponents.UIButtonRadio\r\n   * @return {String}\r\n   */\n\t\tget: function get() {\n\t\t\treturn _EVENT_SELECT;\n\t\t}\n\n\t\t/**\r\n   * @class UIButtonRadio\r\n   * @memberOf UIComponents\r\n   * @extends UIButtonSelect\r\n   * @classdesc\r\n   * Radio button.\r\n   * Several radio buttons can be grouped by appending them to the first button in the group,\r\n   * You can do it via passing first button to `appendTo` constructor argument of other instances,\r\n   * or use [appendToRadio]{@link UIComponents.UIButtonRadio#appendToRadio} method.\r\n   *\r\n   * @extends UIComponents.UIButtonSelect\r\n   * @emits EVENT_SELECT\r\n   * @param {UIComponentPrototype?} parent Parent component to find clip instance in\r\n   * @param {String} [key] this instance clip key to find the clip\r\n   * @param {String} [labelText] Button label text\r\n   * @param {*} [value] Any value, applied to current radio button instance.\r\n   * Use it to find out, what is the current selected value in the group,\r\n   * or select radio by provided value\r\n   * @param {UIButtonRadio} [appendTo] If specified, this instance will be appended\r\n   * to provided radio group immediately\r\n   */\n\n\t}]);\n\n\tfunction UIButtonRadio(parent, key, labelText, value, appendTo) {\n\t\t_classCallCheck(this, UIButtonRadio);\n\n\t\tvar _this = _possibleConstructorReturn(this, (UIButtonRadio.__proto__ || Object.getPrototypeOf(UIButtonRadio)).call(this, parent, key, labelText));\n\n\t\t_this._sibling = _this;\n\t\t_this._value = value;\n\t\tif (appendTo !== undefined) _this.appendToRadio(appendTo);\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * @method UIComponents.UIButtonRadio#appendToRadio\r\n  * @description\r\n  * Append this radio instance to provided radio sibling ring\r\n  * @param {UIButtonRadio} radio radio button to append to sibling ring\r\n  */\n\n\n\t_createClass(UIButtonRadio, [{\n\t\tkey: \"appendToRadio\",\n\t\tvalue: function appendToRadio(radio) {\n\t\t\tif (this._sibling !== this) this.removeFromSibling();\n\t\t\tthis._sibling = radio._sibling;\n\t\t\tradio._sibling = this;\n\t\t}\n\n\t\t/**\r\n   * @method UIButtonRadio#removeFromSibling\r\n   * @description\r\n   * Remove this radio button from sibling ring\r\n   */\n\n\t}, {\n\t\tkey: \"removeFromSibling\",\n\t\tvalue: function removeFromSibling() {}\n\t\t// TODO\n\n\n\t\t/**\r\n   * @method UIComponents.UIButtonRadio#_onClick\r\n   * @inheritDoc\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: \"_onClick\",\n\t\tvalue: function _onClick() {\n\t\t\tthis.select = true;\n\t\t}\n\t}, {\n\t\tkey: \"_broadcastSelect\",\n\n\n\t\t/**\r\n   * @method UIComponents.UIButtonRadio#_broadcastSelect\r\n   * @description\r\n   * Broadcast select event from all siblings\r\n   * @private\r\n   * @ignore\r\n   */\n\t\tvalue: function _broadcastSelect() {\n\t\t\tthis.emit(_EVENT_SELECT, this.value);\n\t\t\tvar radio = this._sibling;\n\t\t\twhile (radio !== this) {\n\t\t\t\tradio.emit(_EVENT_SELECT, this._value);\n\t\t\t\tradio = radio._sibling;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"select\",\n\t\tget: function get() {\n\t\t\treturn _get(UIButtonRadio.prototype.__proto__ || Object.getPrototypeOf(UIButtonRadio.prototype), \"select\", this);\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this._select === val) return;\n\t\t\t_set(UIButtonRadio.prototype.__proto__ || Object.getPrototypeOf(UIButtonRadio.prototype), \"select\", val, this);\n\t\t\tif (val) {\n\t\t\t\tvar radio = this._sibling;\n\t\t\t\twhile (radio !== this) {\n\t\t\t\t\tradio.select = false;\n\t\t\t\t\tradio = radio._sibling;\n\t\t\t\t}\n\t\t\t\tthis._broadcastSelect();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"value\",\n\t\tget: function get() {\n\t\t\treturn this._value;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tthis._value = val;\n\t\t}\n\t}, {\n\t\tkey: \"valueSelected\",\n\t\tget: function get() {\n\t\t\tif (this.select) return this.value;\n\t\t\tvar radio = this._sibling;\n\t\t\twhile (radio !== this) {\n\t\t\t\tif (radio.select) return radio.value;\n\t\t\t\tradio = radio._sibling;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tif (this.value === val) {\n\t\t\t\tthis.select = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar radio = this._sibling;\n\t\t\twhile (radio !== this) {\n\t\t\t\tif (radio.value === val) {\n\t\t\t\t\tradio.select = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn UIButtonRadio;\n}(_UIButtonSelect3.default);\n\nexports.default = UIButtonRadio;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIButtonRadio.js?");

/***/ }),

/***/ "./src/components/UIButtonSelect.js":
/*!******************************************!*\
  !*** ./src/components/UIButtonSelect.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _UIButton2 = __webpack_require__(/*! ./UIButton */ \"./src/components/UIButton.js\");\n\nvar _UIButton3 = _interopRequireDefault(_UIButton2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * @class UIButtonSelect\r\n * @memberOf UIComponents\r\n * @classdesc\r\n * Checkbox-like button component prototype.\r\n * Has states `up`, `over`, `down`, `disable`, `up_select`, `over_select`, `down_select`, `disable_select`,\r\n * Emits EVENT_CLICK on click.\r\n * When disabled, doesn't interact to mouse events and move to state `disable`\r\n * @extends UIButton\r\n * @emits EVENT_CLICK\r\n *\r\n * @property {Boolean} enable activate/deactivate button interaction. if false, button state is set to `disable`\r\n * @property {String} label get/set button label text\r\n * @property {Boolean} select get/set switch\r\n *\r\n * @param {UIComponentPrototype} parent\r\n * @param {String} key\r\n * @param {String?} labelText\r\n */\nvar UIButtonSelect = function (_UIButton) {\n\t_inherits(UIButtonSelect, _UIButton);\n\n\tfunction UIButtonSelect(parent, key, labelText) {\n\t\t_classCallCheck(this, UIButtonSelect);\n\n\t\t/**\r\n   * button as selected or not\r\n   * @type {Boolean}\r\n   * @private\r\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (UIButtonSelect.__proto__ || Object.getPrototypeOf(UIButtonSelect)).call(this, parent, key, labelText));\n\n\t\t_this._select = false;\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * @method UIComponents.UIButtonSelect#getStateId\r\n  * @inheritDoc\r\n  * @returns {String}\r\n  */\n\n\n\t_createClass(UIButtonSelect, [{\n\t\tkey: 'getStateId',\n\t\tvalue: function getStateId() {\n\t\t\treturn _get(UIButtonSelect.prototype.__proto__ || Object.getPrototypeOf(UIButtonSelect.prototype), 'getStateId', this).call(this) + (this._select ? '_select' : '');\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIButtonSelect#_onClick\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: '_onClick',\n\t\tvalue: function _onClick() {\n\t\t\tthis._select = !this._select;\n\t\t\tthis.doState();\n\t\t\t_get(UIButtonSelect.prototype.__proto__ || Object.getPrototypeOf(UIButtonSelect.prototype), '_onClick', this).call(this);\n\t\t}\n\t}, {\n\t\tkey: 'select',\n\t\tget: function get() {\n\t\t\treturn this._select;\n\t\t},\n\t\tset: function set(value) {\n\t\t\tif (this._select === value) return;\n\t\t\tthis._select = value;\n\t\t\tthis.doState();\n\t\t}\n\t}]);\n\n\treturn UIButtonSelect;\n}(_UIButton3.default);\n\nexports.default = UIButtonSelect;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIButtonSelect.js?");

/***/ }),

/***/ "./src/components/UIComponentPrototype.js":
/*!************************************************!*\
  !*** ./src/components/UIComponentPrototype.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _phaser = __webpack_require__(/*! phaser */ \"phaser\");\n\nvar _phaser2 = _interopRequireDefault(_phaser);\n\nvar _ComponentClip = __webpack_require__(/*! ../clip/ComponentClip */ \"./src/clip/ComponentClip.js\");\n\nvar _ComponentClip2 = _interopRequireDefault(_ComponentClip);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _EVENT_STATE = 'event_state';\n\n/**\r\n * @memberOf PhaserComps.UIComponents\r\n * @class UIComponentPrototype\r\n * @classdesc Base ComponentView controller class. Used to setup component state and texts.\r\n * Once root instance is created, you must append a [ComponentClip]{@link PhaserComps.ComponentClip}\r\n * instance to it.\r\n *\r\n * Child clips will be appended automatically on every state change, their clips will be found by keys.\r\n * On state change notifies all child components to update their states.\r\n *\r\n * *One of the main ideas of this framework is if there is no clip for ComponentPrototype\r\n * at current state or at all, nothing bad happens.*\r\n *\r\n * @extends Phaser.Events.EventEmitter\r\n * @param {UIComponentPrototype} [parent] component prototype instance to find clip inside\r\n * @param {String} [key] key to find clip inside parent\r\n */\n\nvar UIComponentPrototype = function (_Phaser$Events$EventE) {\n\t_inherits(UIComponentPrototype, _Phaser$Events$EventE);\n\n\t_createClass(UIComponentPrototype, null, [{\n\t\tkey: 'EVENT_STATE',\n\t\tget: function get() {\n\t\t\treturn _EVENT_STATE;\n\t\t}\n\t}]);\n\n\tfunction UIComponentPrototype(parent, key) {\n\t\t_classCallCheck(this, UIComponentPrototype);\n\n\t\t/**\r\n   *\r\n   * @type {UIComponentPrototype}\r\n   * @private\r\n   */\n\t\tvar _this = _possibleConstructorReturn(this, (UIComponentPrototype.__proto__ || Object.getPrototypeOf(UIComponentPrototype)).call(this));\n\n\t\t_this._parent = parent;\n\n\t\t/**\r\n   *\r\n   * @type {String}\r\n   * @protected\r\n   */\n\t\t_this._key = key;\n\n\t\t/**\r\n   *\r\n   * @type {PhaserComps.ComponentClip}\r\n   * @protected\r\n   */\n\t\t_this._clip = null;\n\n\t\t/**\r\n   *\r\n   * @type {Object<String>}\r\n   * @private\r\n   */\n\t\t_this._texts = {};\n\n\t\tif (key && parent) {\n\t\t\t// sign on parents state update\n\t\t\tparent.on(_EVENT_STATE, _this._onEventState, _this);\n\t\t}\n\t\t_this._clipUpdate();\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * @public\r\n  * @method PhaserComps.UIComponents.UIComponentPrototype#appendClip\r\n  * @description\r\n  * Append a instance to this to control it. State setup will be processed immediately.<br>\r\n  * Use only for root instance, child instances will be appended automatically depending on state of this.\r\n  * @param {PhaserComps.ComponentClip} clip ComponentView instance to append\r\n  */\n\n\n\t_createClass(UIComponentPrototype, [{\n\t\tkey: 'appendClip',\n\t\tvalue: function appendClip(clip) {\n\t\t\tif (this._clip === clip) return;\n\t\t\tif (this._clip !== null) this.removeClip();\n\t\t\tthis._clip = clip;\n\t\t\tif (this._clip) this.onClipAppend(this._clip);\n\t\t\tthis._clipProcess();\n\t\t}\n\n\t\t/**\r\n   *\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#onClipAppend\r\n   * @protected\r\n   * @param {PhaserComps.ComponentClip} clip\r\n   */\n\n\t}, {\n\t\tkey: 'onClipAppend',\n\t\tvalue: function onClipAppend(clip) {}\n\t\t// override me\n\n\n\t\t/**\r\n   * @public\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#removeClip\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: 'removeClip',\n\t\tvalue: function removeClip() {\n\t\t\tthis.onClipRemove(this._clip);\n\t\t\tthis._clip = null;\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#onClipRemove\r\n   * @protected\r\n   * @param clip\r\n   */\n\n\t}, {\n\t\tkey: 'onClipRemove',\n\t\tvalue: function onClipRemove(clip) {}\n\t\t// override me\n\n\n\t\t/**\r\n   * Call doState to setup new state, id is provided by [getStateId]{@link PhaserComps.UIComponents.UIComponentPrototype#getStateId}\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#doState\r\n   * @protected\r\n   * @see PhaserComps.UIComponents.UIComponentPrototype#getStateId\r\n   */\n\n\t}, {\n\t\tkey: 'doState',\n\t\tvalue: function doState() {\n\t\t\tvar stateId = this.getStateId();\n\t\t\tthis._setupState(stateId);\n\t\t}\n\n\t\t/**\r\n   * Returns saved text by key, if it was set previously\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#getText\r\n   * @param {String} key\r\n   * @returns {String|Array<String>} text value\r\n   */\n\n\t}, {\n\t\tkey: 'getText',\n\t\tvalue: function getText(key) {\n\t\t\treturn this._texts[key];\n\t\t}\n\n\t\t/**\r\n   * Set text value to the textfield with provided key.\r\n   * Text value is saved in the component's instance dictionary and will be set to the textField on every state change\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#setText\r\n   * @param {String} key TextField key\r\n   * @param {String|Array<String>} text text string\r\n   */\n\n\t}, {\n\t\tkey: 'setText',\n\t\tvalue: function setText(key, text) {\n\t\t\tif (this._texts[key] === text) return;\n\t\t\tthis._texts[key] = text;\n\t\t\tif (this._clip) {\n\t\t\t\tvar textField = this._clip.getChildText(key);\n\t\t\t\tif (textField) textField.text = text;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#getStateId\r\n   * @description\r\n   * Current state id, used by [doState]{@link PhaserComps.UIComponents.UIComponentPrototype#doState} method\r\n   * @returns {String}\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: 'getStateId',\n\t\tvalue: function getStateId() {\n\t\t\treturn 'default';\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#destroy\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tif (this._parent) this._parent.removeListener(_EVENT_STATE, this._onEventState);\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#_clipUpdate\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_clipUpdate',\n\t\tvalue: function _clipUpdate() {\n\t\t\tif (!this._key) {\n\t\t\t\t// parent is clip itself\n\t\t\t} else {\n\t\t\t\tif (this._parent._clip) {\n\t\t\t\t\tvar clip = this._parent._clip.getChildClip(this._key);\n\t\t\t\t\tthis.appendClip(clip);\n\t\t\t\t} else {\n\t\t\t\t\tthis.appendClip(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#_clipProcess\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_clipProcess',\n\t\tvalue: function _clipProcess() {\n\t\t\tif (!this._clip) return;\n\t\t\tthis.doState();\n\t\t\tthis.onClipProcess();\n\t\t}\n\n\t\t/**\r\n   * Override this, if you want to do something, when state or clip changes.\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#onClipProcess\r\n   * @protected\r\n   * @override\r\n   */\n\n\t}, {\n\t\tkey: 'onClipProcess',\n\t\tvalue: function onClipProcess() {}\n\t\t// override me\n\n\n\t\t/**\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#_setupState\r\n   * @param {String} stateId state id to setup\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_setupState',\n\t\tvalue: function _setupState(stateId) {\n\t\t\tif (this._clip) {\n\t\t\t\tthis._clip.setState(stateId);\n\n\t\t\t\t// update textfields\n\t\t\t\tfor (var textKey in this._texts) {\n\t\t\t\t\tvar textField = this._clip.getChildText(textKey);\n\t\t\t\t\tif (textField) textField.text = this._texts[textKey];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.emit(_EVENT_STATE);\n\t\t}\n\n\t\t/**\r\n   * Parent state change listener\r\n   * @method PhaserComps.UIComponents.UIComponentPrototype#_onEventState\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: '_onEventState',\n\t\tvalue: function _onEventState() {\n\t\t\tthis._clipUpdate();\n\t\t}\n\t}]);\n\n\treturn UIComponentPrototype;\n}(_phaser2.default.Events.EventEmitter);\n\nexports.default = UIComponentPrototype;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIComponentPrototype.js?");

/***/ }),

/***/ "./src/components/UIComponents.js":
/*!****************************************!*\
  !*** ./src/components/UIComponents.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _UIButton = __webpack_require__(/*! ./UIButton */ \"./src/components/UIButton.js\");\n\nvar _UIButton2 = _interopRequireDefault(_UIButton);\n\nvar _UIButtonRadio = __webpack_require__(/*! ./UIButtonRadio */ \"./src/components/UIButtonRadio.js\");\n\nvar _UIButtonRadio2 = _interopRequireDefault(_UIButtonRadio);\n\nvar _UIComponentPrototype = __webpack_require__(/*! ./UIComponentPrototype */ \"./src/components/UIComponentPrototype.js\");\n\nvar _UIComponentPrototype2 = _interopRequireDefault(_UIComponentPrototype);\n\nvar _UIButtonSelect = __webpack_require__(/*! ./UIButtonSelect */ \"./src/components/UIButtonSelect.js\");\n\nvar _UIButtonSelect2 = _interopRequireDefault(_UIButtonSelect);\n\nvar _UIButtonDraggable = __webpack_require__(/*! ./UIButtonDraggable */ \"./src/components/UIButtonDraggable.js\");\n\nvar _UIButtonDraggable2 = _interopRequireDefault(_UIButtonDraggable);\n\nvar _UIScrollBar = __webpack_require__(/*! ./UIScrollBar */ \"./src/components/UIScrollBar.js\");\n\nvar _UIScrollBar2 = _interopRequireDefault(_UIScrollBar);\n\nvar _UIScrollPanel = __webpack_require__(/*! ./UIScrollPanel */ \"./src/components/UIScrollPanel.js\");\n\nvar _UIScrollPanel2 = _interopRequireDefault(_UIScrollPanel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * @namespace PhaserComps.UIComponents\r\n */\n\nvar UIComponents = {\n\tUIComponentPrototype: _UIComponentPrototype2.default,\n\tUIButton: _UIButton2.default,\n\tUIButtonSelect: _UIButtonSelect2.default,\n\tUIButtonRadio: _UIButtonRadio2.default,\n\tUIButtonDraggable: _UIButtonDraggable2.default,\n\tUIScrollBar: _UIScrollBar2.default,\n\tUIScrollPanel: _UIScrollPanel2.default\n};\n\nexports.default = UIComponents;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIComponents.js?");

/***/ }),

/***/ "./src/components/UIScrollBar.js":
/*!***************************************!*\
  !*** ./src/components/UIScrollBar.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! phaser */ \"phaser\");\n\nvar _UIComponentPrototype2 = __webpack_require__(/*! ./UIComponentPrototype */ \"./src/components/UIComponentPrototype.js\");\n\nvar _UIComponentPrototype3 = _interopRequireDefault(_UIComponentPrototype2);\n\nvar _UIButton = __webpack_require__(/*! ./UIButton */ \"./src/components/UIButton.js\");\n\nvar _UIButton2 = _interopRequireDefault(_UIButton);\n\nvar _UIButtonDraggable = __webpack_require__(/*! ./UIButtonDraggable */ \"./src/components/UIButtonDraggable.js\");\n\nvar _UIButtonDraggable2 = _interopRequireDefault(_UIButtonDraggable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _EVENT_CHANGE = 'event_change';\n\nvar UIScrollBar = function (_UIComponentPrototype) {\n\t_inherits(UIScrollBar, _UIComponentPrototype);\n\n\t_createClass(UIScrollBar, null, [{\n\t\tkey: \"EVENT_CHANGE\",\n\t\tget: function get() {\n\t\t\treturn _EVENT_CHANGE;\n\t\t}\n\n\t\t/**\r\n   * @class UIScrollBar\r\n   * @memberOf UIComponents\r\n   * @classdesc\r\n   * Scroll bar component. can be vertical or horizontal <br>\r\n   * It have up and down buttons inside, draggable thumb button. <br>\r\n   * 'dimensions' zone defines thumb drag bounds.\r\n   *\r\n   * default value range is 0 to 1, You can change it by setting\r\n   * min and max value. Also you can set value step, so value will always\r\n   * be stepped by it\r\n   *\r\n   *\r\n   * @property {Number} value current bar value, from min value to max, default is from 0 to 1\r\n   * @param {UIComponentPrototype} parent parent ComponentPrototype to find clip instance in\r\n   * @param {String} key\r\n   * @param {Boolean} [vertical=false] scroll bar behave like vertical or horizontal\r\n   */\n\n\t}]);\n\n\tfunction UIScrollBar(parent, key, vertical) {\n\t\t_classCallCheck(this, UIScrollBar);\n\n\t\tvar _this = _possibleConstructorReturn(this, (UIScrollBar.__proto__ || Object.getPrototypeOf(UIScrollBar)).call(this, parent, key));\n\n\t\t_this._vertical = vertical || false;\n\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._value = 0;\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._minValue = 0;\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._maxValue = 1;\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._valueStep = 0;\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._buttonStep = 0.1;\n\n\t\t/**\r\n   * scroll up/left button\r\n   * @type {UIButton}\r\n   */\n\t\t_this.btnPrev = new _UIButton2.default(_this, 'btn_up');\n\t\t_this.btnPrev.on(_UIButton2.default.EVENT_CLICK, _this.onPrevClick, _this);\n\t\t/**\r\n   * scroll down/right button\r\n   * @type {UIButton}\r\n   */\n\t\t_this.btnNext = new _UIButton2.default(_this, 'btn_down');\n\t\t_this.btnNext.on(_UIButton2.default.EVENT_CLICK, _this.onNextClick, _this);\n\n\t\t/**\r\n   *\r\n   * @type {UIButtonDraggable}\r\n   */\n\t\t_this.thumb = new _UIButtonDraggable2.default(_this, 'thumb');\n\t\t_this.thumb.on(_UIButtonDraggable2.default.EVENT_DRAG, _this.onThumbDrag, _this);\n\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._trackStart = 0;\n\t\t/**\r\n   *\r\n   * @type {number}\r\n   * @private\r\n   */\n\t\t_this._trackLength = 100;\n\n\t\t/**\r\n   *\r\n   * @type {ComponentClip}\r\n   * @private\r\n   */\n\t\t_this._thumbClip = null;\n\t\treturn _this;\n\t}\n\n\t/**\r\n  * @method UIComponents.UIScrollBar#setValueBounds\r\n  * @param {Number} minValue\r\n  * @param {Number} maxValue\r\n  * @param {Number} [valueStep=0]\r\n  */\n\n\n\t_createClass(UIScrollBar, [{\n\t\tkey: \"setValueBounds\",\n\t\tvalue: function setValueBounds(minValue, maxValue, valueStep) {\n\t\t\tthis._minValue = minValue;\n\t\t\tthis._maxValue = maxValue;\n\t\t\tif (valueStep !== undefined) {\n\t\t\t\tthis._valueStep = valueStep;\n\t\t\t\tif (this._buttonStep < valueStep) this._buttonStep = valueStep;\n\t\t\t} else {\n\t\t\t\tthis._valueStep = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#setButtonStep\r\n   * @param {Number} val\r\n   */\n\n\t}, {\n\t\tkey: \"setButtonStep\",\n\t\tvalue: function setButtonStep(val) {\n\t\t\tthis._buttonStep = val;\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#onClipAppend\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: \"onClipAppend\",\n\t\tvalue: function onClipAppend(clip) {\n\t\t\t_get(UIScrollBar.prototype.__proto__ || Object.getPrototypeOf(UIScrollBar.prototype), \"onClipAppend\", this).call(this, clip);\n\t\t\tthis._updateClips();\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#_updateClips\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: \"_updateClips\",\n\t\tvalue: function _updateClips() {\n\t\t\tif (!this._clip) return;\n\t\t\tthis._thumbClip = this.thumb._clip;\n\t\t\tvar trackClip = this._clip.getChildClip('DIMENSIONS');\n\t\t\tif (trackClip) {\n\t\t\t\tthis._trackStart = this._vertical ? trackClip.y : trackClip.x;\n\t\t\t\tthis._trackLength = this._vertical ? trackClip.height : trackClip.width;\n\n\t\t\t\tif (this._thumbClip) {\n\t\t\t\t\tthis.thumb.setDragBounds(this._vertical ? this._thumbClip.x : trackClip.x, this._vertical ? trackClip.y : this._thumbClip.y, this._vertical ? this._thumbClip.x : trackClip.x + trackClip.width, this._vertical ? trackClip.y + trackClip.height : this._thumbClip.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar hitZone = this._clip.getChildClip('HIT_ZONE');\n\t\t\tif (hitZone) {\n\t\t\t\thitZone.on('pointerdown', this.onZoneDown, this);\n\t\t\t\t//hitZone.on('pointerup', this.onZoneUp, this);\n\t\t\t}\n\t\t\tthis._updateThumbFromValue();\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#onClipProcess\r\n   * @inheritDoc\r\n   */\n\n\t}, {\n\t\tkey: \"onClipProcess\",\n\t\tvalue: function onClipProcess() {\n\t\t\t_get(UIScrollBar.prototype.__proto__ || Object.getPrototypeOf(UIScrollBar.prototype), \"onClipProcess\", this).call(this);\n\t\t\tif (!this.thumb) // call from super constructor\n\t\t\t\treturn;\n\t\t\tthis._updateClips();\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#onPrevClick\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: \"onPrevClick\",\n\t\tvalue: function onPrevClick() {\n\t\t\tthis.value -= this._buttonStep;\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#onNextClick\r\n   * @protected\r\n   */\n\n\t}, {\n\t\tkey: \"onNextClick\",\n\t\tvalue: function onNextClick() {\n\t\t\tthis.value += this._buttonStep;\n\t\t}\n\n\t\t/**\r\n   * @method UIComponents.UIScrollBar#_updateThumbFromValue\r\n   * @private\r\n   */\n\n\t}, {\n\t\tkey: \"_updateThumbFromValue\",\n\t\tvalue: function _updateThumbFromValue() {\n\t\t\tif (!this._thumbClip) return;\n\t\t\tvar barPosition = Math.round(this._trackStart + this._trackLength * this._value);\n\t\t\tif (this._vertical) {\n\t\t\t\tthis._thumbClip.y = barPosition;\n\t\t\t} else {\n\t\t\t\tthis._thumbClip.x = barPosition;\n\t\t\t}\n\t\t\tthis.emit(_EVENT_CHANGE, this.value);\n\t\t}\n\t}, {\n\t\tkey: \"onThumbDrag\",\n\t\tvalue: function onThumbDrag(positionX, positionY) {\n\t\t\tif (this._trackLength === 0) return;\n\t\t\tvar barPosition = this._vertical ? positionY : positionX;\n\t\t\tvar newValue = (barPosition - this._trackStart) / this._trackLength;\n\t\t\tvar v = newValue * (this._maxValue - this._minValue);\n\t\t\tif (this._valueStep !== 0) v = Math.round(v / this._valueStep) * this._valueStep;\n\t\t\t// minValue added only after step normalization\n\t\t\tthis.value = v + this._minValue;\n\t\t}\n\t}, {\n\t\tkey: \"onZoneDown\",\n\t\tvalue: function onZoneDown() {\n\t\t\tconsole.log(arguments);\n\t\t}\n\t}, {\n\t\tkey: \"value\",\n\t\tget: function get() {\n\t\t\tvar v = this._value * (this._maxValue - this._minValue);\n\t\t\tif (this._valueStep === 0) return v + this._minValue;\n\t\t\tv = Math.round(v / this._valueStep) * this._valueStep;\n\t\t\treturn v + this._minValue;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tvar v = (val - this._minValue) / (this._maxValue - this._minValue);\n\t\t\tif (v < 0) v = 0;\n\t\t\tif (v > 1) v = 1;\n\t\t\tif (v === this._value) return;\n\t\t\tthis._value = v;\n\t\t\tthis._updateThumbFromValue();\n\t\t}\n\t}]);\n\n\treturn UIScrollBar;\n}(_UIComponentPrototype3.default);\n\nexports.default = UIScrollBar;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIScrollBar.js?");

/***/ }),

/***/ "./src/components/UIScrollPanel.js":
/*!*****************************************!*\
  !*** ./src/components/UIScrollPanel.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _UIComponentPrototype = __webpack_require__(/*! ./UIComponentPrototype */ \"./src/components/UIComponentPrototype.js\");\n\nvar _UIComponentPrototype2 = _interopRequireDefault(_UIComponentPrototype);\n\nvar _UIScrollBar = __webpack_require__(/*! ./UIScrollBar */ \"./src/components/UIScrollBar.js\");\n\nvar _UIScrollBar2 = _interopRequireDefault(_UIScrollBar);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar UIScrollPanel = function () {\n\n\t/**\r\n  * @typedef ScrollLimitsObject\r\n  * @description\r\n  * Object is generated automatically on container's clip update, by the `dimensions` clip\r\n  * @memberOf UIComponents.UIScrollPanel\r\n  * @property {Number} x Start x position of the container. Used, if panel is horizontal\r\n  * @property {Number} y Start x position of the container. Used, if panel is vertical\r\n  * @property {Number} len Scroll distance of the container. On scroll down/right,\r\n  * x or y position will be subtracted by `len` multiplied by scrollbar value\r\n  */\n\n\t/**\r\n  * @class UIScrollPanel\r\n  * @classdesc\r\n  * Scrolling panel with scrollbar applied to it.\r\n  * First parameter is container, where this should find the panel, scroll bar and dimensions instances\r\n  * UIScrollBar instance created inside with a provided `scrollBarKey` <br><br>\r\n  * **Warning! This component doesn't extend UIComponent.ComponentPrototype**\r\n  *\r\n  * @memberOf UIComponents\r\n  * @param {UIComponentPrototype} container\r\n  * @param {String} panelKey\r\n  * @param {String} scrollBarKey\r\n  * @param {String} dimensionsKey\r\n  * @param {Boolean} [vertical=false]\r\n  */\n\tfunction UIScrollPanel(container, panelKey, scrollBarKey, dimensionsKey, vertical) {\n\t\t_classCallCheck(this, UIScrollPanel);\n\n\t\t/** @type UIComponentPrototype */\n\t\tthis._container = container;\n\t\tcontainer.on(_UIComponentPrototype2.default.EVENT_STATE, this._onContainerUpdate, this);\n\n\t\t/** @type String */\n\t\tthis._panelKey = panelKey;\n\t\t/** @type String */\n\t\tthis._dimensionsKey = dimensionsKey;\n\n\t\t/** @type UIScrollBar */\n\t\tthis._scrollBar = new _UIScrollBar2.default(container, scrollBarKey, vertical);\n\t\tthis._scrollBar.on(_UIScrollBar2.default.EVENT_CHANGE, this._onScrollBar, this);\n\n\t\t/** @type Boolean */\n\t\tthis._vertical = vertical || false;\n\t}\n\n\t/**\r\n  *\r\n  * @method UIScrollPanel#_onContainerUpdate\r\n  * @private\r\n  */\n\n\n\t_createClass(UIScrollPanel, [{\n\t\tkey: \"_onContainerUpdate\",\n\t\tvalue: function _onContainerUpdate() {\n\t\t\tif (!this._container._clip) return;\n\t\t\t/**\r\n    *\r\n    * @type ComponentClip\r\n    */\n\t\t\tvar clip = this._container._clip;\n\t\t\tvar panel = clip.getChildClip(this._panelKey);\n\t\t\tvar dims = clip.getChildClip(this._dimensionsKey);\n\t\t\tif (!panel || !dims) return;\n\n\t\t\t/**\r\n    *\r\n    * @type ScrollLimitsObject\r\n    */\n\t\t\tthis.scrollLimits = {\n\t\t\t\tx: dims.x,\n\t\t\t\ty: dims.y,\n\t\t\t\tlen: this._vertical ? panel.height - dims.height : panel.width - dims.width\n\t\t\t};\n\n\t\t\t/**\r\n    * @type ComponentClip\r\n    */\n\t\t\tthis._panel = panel;\n\t\t}\n\t}, {\n\t\tkey: \"_onScrollBar\",\n\t\tvalue: function _onScrollBar(value) {\n\t\t\tif (!this._panel) return;\n\t\t\tif (this._vertical) {\n\t\t\t\tthis._panel.y = this.scrollLimits.y - this.scrollLimits.len * value;\n\t\t\t} else {\n\t\t\t\tthis._panel.x = this.scrollLimits.x - this.scrollLimits.len * value;\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn UIScrollPanel;\n}();\n\nexports.default = UIScrollPanel;\n\n//# sourceURL=webpack://PhaserComps/./src/components/UIScrollPanel.js?");

/***/ }),

/***/ "./src/phasercomps.js":
/*!****************************!*\
  !*** ./src/phasercomps.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _ComponentClip = __webpack_require__(/*! ./clip/ComponentClip */ \"./src/clip/ComponentClip.js\");\n\nvar _ComponentClip2 = _interopRequireDefault(_ComponentClip);\n\nvar _UIComponents = __webpack_require__(/*! ./components/UIComponents */ \"./src/components/UIComponents.js\");\n\nvar _UIComponents2 = _interopRequireDefault(_UIComponents);\n\nvar _Plugin = __webpack_require__(/*! ./plugin/Plugin */ \"./src/plugin/Plugin.js\");\n\nvar _Plugin2 = _interopRequireDefault(_Plugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PhaserComps = {\n\tComponentClip: _ComponentClip2.default,\n\tUIComponents: _UIComponents2.default,\n\tPlugin: _Plugin2.default\n}; /**\r\n    * @namespace PhaserComps\r\n    */\n\nmodule.exports = PhaserComps;\n\nglobal.PhaserComps = PhaserComps;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://PhaserComps/./src/phasercomps.js?");

/***/ }),

/***/ "./src/plugin/Plugin.js":
/*!******************************!*\
  !*** ./src/plugin/Plugin.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _phaser = __webpack_require__(/*! phaser */ \"phaser\");\n\nvar _phaser2 = _interopRequireDefault(_phaser);\n\nvar _ComponentClip = __webpack_require__(/*! ../clip/ComponentClip */ \"./src/clip/ComponentClip.js\");\n\nvar _ComponentClip2 = _interopRequireDefault(_ComponentClip);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * @class Plugin\r\n * @memberOf PhaserComps\r\n * @classdesc\r\n * Phaser 3 plugin, adds `ui_component` method to scene GameObjectFactory and GameObjectCreator,\r\n * that creates a {@link PhaserComps.ComponentClip} instance\r\n *\r\n * *Note. Factory method (`scene.make.ui_component()`) also adds clip instance to scene*\r\n *\r\n * Implementation example:\r\n * ```javascript\r\n * import 'phaser-ui-jsfl'\r\n *\r\n * var config = {\r\n *  type: Phaser.AUTO,\r\n *  parent: 'example',\r\n *  width: 800,\r\n *  height: 600,\r\n *  scene: {\r\n *  \tcreate: create\r\n *  },\r\n *  plugins: {\r\n *  \tglobal: [\r\n *  \t\tPhaserComps.DefaultCfg\r\n *  \t]\r\n *  }\r\n *\r\n * create() {\r\n *     let configObject = {}; // here must be real jsfl-generated config object\r\n *     let texture_name = 'your_texture_name';\r\n *     this.add.ui_component(this, configObject, [texture_name]);\r\n * }\r\n *\r\n * @see\r\n};\r\n\r\n * ```\r\n */\nvar Plugin = function (_Phaser$Plugins$BaseP) {\n    _inherits(Plugin, _Phaser$Plugins$BaseP);\n\n    function Plugin(mgr) {\n        _classCallCheck(this, Plugin);\n\n        var _this = _possibleConstructorReturn(this, (Plugin.__proto__ || Object.getPrototypeOf(Plugin)).call(this, mgr));\n\n        mgr.registerGameObject('ui_component', _this.addComponent, _this.addComponent);\n        return _this;\n    }\n\n    _createClass(Plugin, [{\n        key: 'addComponent',\n        value: function addComponent(config, textures) {\n            return new _ComponentClip2.default(this.scene, config, textures);\n        }\n    }]);\n\n    return Plugin;\n}(_phaser2.default.Plugins.BasePlugin);\n\nexports.default = Plugin;\n\n\nvar DefaultCfg = {\n    key: 'UIComponents',\n    plugin: Plugin,\n    start: true\n};\n\nPlugin.DefaultCfg = DefaultCfg;\n\n//# sourceURL=webpack://PhaserComps/./src/plugin/Plugin.js?");

/***/ }),

/***/ 0:
/*!**********************************!*\
  !*** multi ./src/phasercomps.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/phasercomps.js */\"./src/phasercomps.js\");\n\n\n//# sourceURL=webpack://PhaserComps/multi_./src/phasercomps.js?");

/***/ }),

/***/ "phaser":
/*!*********************************************************************************************************!*\
  !*** external {"umd":"phaser","commonjs2":"phaser","commonjs":"phaser","amd":"phaser","root":"Phaser"} ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_phaser__;\n\n//# sourceURL=webpack://PhaserComps/external_%7B%22umd%22:%22phaser%22,%22commonjs2%22:%22phaser%22,%22commonjs%22:%22phaser%22,%22amd%22:%22phaser%22,%22root%22:%22Phaser%22%7D?");

/***/ }),

/***/ "underscore":
/*!********************************************************************************************************************!*\
  !*** external {"umd":"underscore","commonjs2":"underscore","commonjs":"underscore","amd":"underscore","root":"_"} ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_underscore__;\n\n//# sourceURL=webpack://PhaserComps/external_%7B%22umd%22:%22underscore%22,%22commonjs2%22:%22underscore%22,%22commonjs%22:%22underscore%22,%22amd%22:%22underscore%22,%22root%22:%22_%22%7D?");

/***/ })

/******/ });
});